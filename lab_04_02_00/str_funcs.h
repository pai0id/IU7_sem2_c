#ifndef STR_FUNCS_H
#define STR_FUNCS_H

#include "sizes.h"
#include <stdio.h>
#include <string.h>

/// \brief Считывает строку с клавиатуры.
/// Буфер существует, размер корректный.
///
/// \param buf [in] - указатель на буфер, в который будет записана считанная строка
/// \param buf_size [in] - размер буфера
///
/// \return Код ошибки:
///         - OK, если строка успешно считана и обработана
///         - ERR_IO, если произошла ошибка ввода-вывода
///         - ERR_BUF_TOO_SMALL, если размер буфера недостаточен для считывания строки
int get_line(char *buf, size_t buf_size);

/// \brief Находит следующее слово в строке.
/// Строка корректна.
///
/// \param str [in] - указатель на строку, в которой будет производиться поиск
/// \param pbeg [out] - указатель на указатель на начало найденного слова
/// \param pend [out] - указатель на указатель на конец найденного слова
///
/// \note Функция изменяет значения указателей pbeg и pend
/// на адреса начала и конца найденного слова соответственно.
/// Если слово не найдено, то значения указателей остаются неизменными.
void get_next_word(char *str, char **pbeg, char **pend);

/// \brief Копирует найденное слово в новый буфер.
/// Буфер существует, слово существует.
///
/// \param pbeg [in] - указатель на начало найденного слова
/// \param pend [in] - указатель на конец найденного слова
/// \param word [out] - указатель на буфер, в который будет скопировано слово
/// \param word_size [in] - размер буфера
///
/// \return Код ошибки:
///         - OK, если слово успешно скопировано
///         - ERR_BUF_TOO_SMALL, если размер буфера недостаточен для копирования слова
int copy_word(char *pbeg, const char *pend, char *word, size_t word_size);

/// \brief Разбивает строку на слова и копирует их в массив.
/// Строка существует и корректна, массив существует.
///
/// \param str [in] - указатель на строку, которую нужно разбить на слова
/// \param words [out] - массив, в который будут скопированы слова
/// \param words_n [out] - указатель на переменную, в которую будет записано количество скопированных слов
///
/// \return Код ошибки:
///         - OK, если все слова успешно скопированы
///         - ERR_BUF_TOO_SMALL, если размер буфера недостаточен для копирования слова
///         - ERR_TOO_MANY_WORDS, если количество слов превышает максимально допустимое значение
///
/// \note Функция использует функции get_next_word и copy_word
/// для разбиения строки на слова и копирования их в массив.
int parse_string(char *str, char words[][WRD_LEN + 1], size_t *words_n);

/**
 * \brief Вычисляет количество уникальных слов и их частоту в массиве слов.
 *
 * \param words [in] - массив слов
 * \param words_n [in] - количество слов в массиве
 * \param unique_words [out] - массив для хранения уникальных слов
 * \param unique_words_n [out] - указатель на переменную для сохранения размера уникальных слов
 * \param cnt_arr [out] - массив для хранения частоты уникальных слов
 */
void get_counts(char words[][WRD_LEN + 1], size_t words_n, 
char unique_words[][WRD_LEN + 1], size_t *unique_words_n, int cnt_arr[]);

/**
 * \brief Выводит результат подсчета уникальных слов и их частоты.
 *
 * \param uniwords [in] - массив уникальных слов
 * \param words_n [in] - размер массива уникальных слов
 * \param cnt_arr [in] - массив частоты уникальных слов
 */
void print_counts(char uniwords[][WRD_LEN + 1], size_t words_n, int cnt_arr[]);

#endif
